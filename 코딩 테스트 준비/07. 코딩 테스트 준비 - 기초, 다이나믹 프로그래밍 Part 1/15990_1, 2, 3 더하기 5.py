# 백준 15990번 문제 - 1, 2, 3 더하기 5
# 문제 설명:
# n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하되, 
# 같은 숫자가 연속해서 사용되지 않도록 한다.

# 입력: 자연수 T (테스트 케이스의 수)와 각 테스트 케이스의 n값 (1 ≤ n ≤ 100,000)
# 출력: 각 테스트 케이스에 대해 가능한 경우의 수를 1,000,000,009로 나눈 나머지를 출력

MOD = 1000000009  # 나머지 연산에 사용할 값

# dp 테이블 생성 (최대 n이 100,000이므로 100,001 크기로 생성)
dp = [[0] * 4 for _ in range(100001)]

# 초기 값 설정
dp[1][1] = 1  # 1을 만드는 경우 (1)
dp[2][2] = 1  # 2를 만드는 경우 (2)
dp[3][1] = 1  # 1+2 형태
dp[3][2] = 1  # 2+1 형태
dp[3][3] = 1  # 3을 만드는 경우 (3)

# 동적 계획법으로 dp 테이블 채우기
for i in range(4, 100001):
    dp[i][1] = (dp[i - 1][2] + dp[i - 1][3]) % MOD  # 마지막 숫자가 1인 경우
    dp[i][2] = (dp[i - 2][1] + dp[i - 2][3]) % MOD  # 마지막 숫자가 2인 경우
    dp[i][3] = (dp[i - 3][1] + dp[i - 3][2]) % MOD  # 마지막 숫자가 3인 경우

# 테스트 케이스 수 입력
T = int(input())

# 테스트 케이스 처리
for _ in range(T):
    n = int(input())
    # n을 만드는 모든 경우의 수 출력
    print((dp[n][1] + dp[n][2] + dp[n][3]) % MOD)






# # 백준 15990번 문제 - 1, 2, 3 더하기 5 (디버깅 추가)
# MOD = 1000000009  # 나머지 연산에 사용할 값

# # dp 테이블 생성 (최대 n이 100,000이므로 100,001 크기로 생성)
# dp = [[0] * 4 for _ in range(100001)]

# # 초기 값 설정
# dp[1][1] = 1  # 1을 만드는 경우 (1)
# dp[2][2] = 1  # 2를 만드는 경우 (2)
# dp[3][1] = 1  # 1 + 2
# dp[3][2] = 1  # 2 + 1
# dp[3][3] = 1  # 3

# # 디버깅을 위한 출력
# print("초기 dp 테이블 설정")
# print(dp[:4])  # 처음 4개의 dp 배열 출력

# # 동적 계획법으로 dp 테이블 채우기
# for i in range(4, 100001):
#     dp[i][1] = (dp[i - 1][2] + dp[i - 1][3]) % MOD  # 마지막 숫자가 1인 경우
#     dp[i][2] = (dp[i - 2][1] + dp[i - 2][3]) % MOD  # 마지막 숫자가 2인 경우
#     dp[i][3] = (dp[i - 3][1] + dp[i - 3][2]) % MOD  # 마지막 숫자가 3인 경우
    
#     # 디버깅용 출력: 각 i에 대한 dp 값 확인
#     if i <= 10:  # 10까지의 값만 확인
#         print(f"dp[{i}] = {dp[i]}")

# # 테스트 케이스 수 입력
# T = int(input())

# # 테스트 케이스 처리
# for _ in range(T):
#     n = int(input())
#     # n을 만드는 모든 경우의 수 출력
#     print(f"n = {n}, 가능한 경우의 수: {(dp[n][1] + dp[n][2] + dp[n][3]) % MOD}")
